# 红黑树
- [红黑树实现源码](../../../src/main/java/cool/zzy/demo/datastructure/tree/RBTree.java)
- [测试用例](../../../src/test/java/xyz/zzyitj/demo/datastructure/tree/RBTreeTest.java)

各种树的时间复杂度对比：

| 操作 | 二叉查找树 | 平衡二叉树 | 红黑树 |
| ---- | -------- | -------- | ----- |
| 查找 | O(n) | O(logn) | Olog(n) |
| 插入 |	O(n) | O(logn) | Olog(n) |
| 删除 |	O(n) | O(logn) | Olog(n) |

# 基本性质
```java
/**
 * 1：节点只能是红色或者黑色
 * 2：根节点只能是黑色
 * 3：叶子节点（NIL）只能是黑色
 * 4：如果一个节点是红色的，那么它的两个叶子节点一定是黑色的
 * 可以推导出不能有两个连续的红色节点
 * 5：从任意节点到其后代节点的简单路径上经过的黑色节点的数目都一样
 * 简称黑高相同
 */
```
# 左右旋
左旋
```java
    /*
     * 对红黑树的节点(x)进行左旋转
     *
     * 左旋示意图(对节点x进行左旋)：
     *      px                              px
     *     /                               /
     *    x                               y
     *   /  \      --(左旋)-.           / \                #
     *  lx   y                          x  ry
     *     /   \                       /  \
     *    ly   ry                     lx  ly
     *
     *
     */
```
右旋
```java
    /*
     * 对红黑树的节点(y)进行右旋转
     *
     * 右旋示意图(对节点y进行左旋)：
     *            py                               py
     *           /                                /
     *          y                                x
     *         /  \      --(右旋)-.            /  \                     #
     *        x   ry                           lx   y
     *       / \                                   / \                   #
     *      lx  rx                                rx  ry
     *
     */
```

# 插入
先查找到要插入的位置再修复因为插入破坏的红黑树平衡
```java
    /*
     * 知识点：
     *     有父节点并且父节点是红色节点那么一定有祖父节点，因为根节点不可能是红色节点。
     * 可能有这几种情况：
     * 1：空树，直接把根节点染为黑色就行
     * 2：插入节点的父节点为黑色，不需要处理
     * 3：插入节点的父节点为红色，那么有这几种情况
     *     3.1：父节点在祖父节点的左边
     *         3.1.1 叔叔节点存在，并且为红色（父-叔双红），将父亲和叔叔节点染为黑色，将祖父节点染为红色，再把祖父节点当做当前节点递归
     *         3.1.2 叔叔节点不存在或者为黑色
     *             3.1.2.1 要插入的节点在父节点的左边（L-L双红）将父节点染为黑色，将祖父节点染为红色，以祖父节点右旋
     *             3.1.2.2 要插入的节点在父节点的右边（L-R双红）以父节点左旋，形成L-L双红，再把父节点当做当前节点递归
     *     3.2：父节点在祖父节点的右边
     *         3.2.1 叔叔节点存在，并且为红色（父-叔双红），将父亲和叔叔节点染为黑色，将祖父节点染为红色，再把祖父节点当做当前节点递归
     *         3.2.2：叔叔节点不存在或者为黑色
     *             3.2.2.1：要插入的节点在父节点的右边（R-R双红）将父节点染为黑色，将祖父节点染为红色，以祖父节点左旋
     *             3.2.2.2：要插入的节点在父节点的左边（R-L双红）以父节点右旋，形成R-R双红，再把父节点当做当前节点递归
     */
```
# 删除
```java
    /*
     * 首先，将红黑树当作一颗二叉查找树，将该节点从二叉查找树中删除；然后，通过"旋转和重新着色"等一系列来修正该树，
     * 使之重新成为一棵红黑树。详细描述如下：
     * 第一步：将红黑树当作一颗二叉查找树，将节点删除。
     *     这和"删除常规二叉查找树中删除节点的方法是一样的"。分3种情况：
     *         ① 被删除节点没有儿子，即为叶节点。那么，直接将该节点删除就OK了。
     *         ② 被删除节点只有一个儿子。那么，直接删除该节点，并用该节点的唯一子节点顶替它的位置。
     *         ③ 被删除节点有两个儿子。
     *             那么，先找出它的后继节点；然后把“它的后继节点的内容”复制给“该节点的内容”；
     *             之后，删除“它的后继节点”。在这里，后继节点相当于替身，在将后继节点的内容复制给"被删除节点"之后，再将后继节点删除。
     *             这样就巧妙的将问题转换为"删除后继节点"的情况了，下面就考虑后继节点。
     *             在"被删除节点"有两个非空子节点的情况下，它的后继节点不可能是双子非空。
     *             既然"后继节点"不可能双子都非空，就意味着"该节点的后继节点"要么没有儿子，要么只有一个儿子。
     *             若没有儿子，则按"情况① "进行处理；若只有一个儿子，则按"情况② "进行处理。
     *
     * 第二步：通过"旋转和重新着色"等一系列来修正该树，使之重新成为一棵红黑树。
     *         因为"第一步"中删除节点之后，可能会违背红黑树的特性。所以需要通过"旋转和重新着色"来修正该树，使之重新成为一棵红黑树。
     */
```